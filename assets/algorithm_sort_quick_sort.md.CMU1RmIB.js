import{p as u,v as z,q as O,c as w,o as V,j as n,ae as R,af as N,t as U,ag as J,G as $}from"./chunks/framework.BZdfrRur.js";import{R as E,s as Q}from"./chunks/visual.DiLKMx0U.js";const F={class:"hsAV-visu"},K={class:"hsAV-visu_option"},W={class:"hsAV-visu_option_array_control"},X={class:"hsAV-visu_option_array_control-length"},Y=["disabled"],Z={class:"hsAV-visu_option_array_control-interval"},S=["disabled"],tt={class:"hsAV-visu_option_array_control-button"},et=["disabled"],at=["disabled"],lt={key:0,class:"text"},nt={key:1,class:"text"},rt={class:"hsAV-visu_option_array_value"},st={__name:"quick_sort",setup(I){const p=u(),a=u(),_=u(1e3),i=u(new Array),c=u(!1),f=u(!1);let s=new Array,v=new Array,r=new Array,B=0,D=0,x=0;z(()=>{window.addEventListener("resize",()=>{H()})}),O(a,()=>{a.value>500?a.value=500:a.value<0||typeof a.value!="number"?a.value=0:a.value&&typeof a.value=="number"&&G(a.value)});const L=()=>{T(),d()},M=async()=>{if(c.value=!0,f.value=!0,s.length>=2){r=new Array(s.length);for(let t=0;t<s.length;t++)r[t]={index:t,value:v[t]};console.log(r.concat()),r=await k(r.concat(),0,r.length),C(),P(),d()}d(),c.value=!1,f.value=!1},G=t=>{a.value=t,H(),T(),d()},H=()=>{B=p.value.getBoundingClientRect().width/a.value,D=p.value.getBoundingClientRect().height},T=()=>{x=0,i.value=new Array(a.value),v=new Array(a.value),s=new Array(a.value);for(let t=0;t<i.value.length;t++)i.value[t]=Math.round(Math.random()*1e3),i.value[t]>x&&(x=i.value[t]),v[t]=i.value[t],s[t]=t},C=()=>{for(let t=0;t<r.length;t++)s[r[t].index]=t},P=()=>{for(let t=0;t<s.length;t++)i.value[s[t]]=v[t]},d=(t=[{index:-1,color:"red"}])=>{E(v,s,B,D,x,t,p.value)};async function k(t,l,o){let m=o-l,g=new Array(m>=0?m:0);if(m<=1)return t;{C(),P(),d(Array.from(r).map((e,b)=>{for(let h=0;h<t.length;h++){if(e.index===t[0].index)return{index:b,color:"#98fb98"};if(e.index===t[h].index)return{index:b,color:"#ffff20"}}}).filter(e=>e)),await Q(_.value);let y=new Array(0),A=new Array(0);for(let e=1;e<m;e++)t[e].value>t[0].value?A.push(t[e]):y.push(t[e]);g=y.concat(t[0]).concat(A);for(let e=l;e<o;e++)r[e]=g[e-l];C(),P(),d(Array.from(r).map((e,b)=>{for(let h=0;h<g.length;h++){if(e.index===t[0].index)return{index:b,color:"#98fb98"};if(e.index===g[h].index)return{index:b,color:"#ffff20"}}}).filter(e=>e)),await Q(_.value+600);let j=await k(y,l,l+y.length),q=await k(A,o-A.length,o);return j.concat(t[0]).concat(q)}}return(t,l)=>(V(),w("div",F,[n("div",{class:"hsAV-visu_visual",ref_key:"visualDiv",ref:p},null,512),n("div",K,[n("div",W,[n("div",X,[l[2]||(l[2]=n("span",{class:"text"},"数组长度",-1)),R(n("input",{type:"number","onUpdate:modelValue":l[0]||(l[0]=o=>a.value=o),disabled:c.value,min:"0",max:"500",placeholder:"0 - 500"},null,8,Y),[[N,a.value]])]),n("div",Z,[l[3]||(l[3]=n("span",{class:"text"},"动画间隔",-1)),R(n("input",{type:"number","onUpdate:modelValue":l[1]||(l[1]=o=>_.value=o),disabled:c.value,min:"0",max:"1000",placeholder:"1000"},null,8,S),[[N,_.value]])]),n("div",tt,[n("button",{class:"reassign",disabled:c.value,onClick:L},l[4]||(l[4]=[n("div",{class:"text"},"重新赋值",-1)]),8,et),n("button",{class:"start",disabled:f.value,onClick:M},[f.value?(V(),w("div",lt,"运行中")):(V(),w("div",nt,"开始"))],8,at)])]),n("div",rt,[l[5]||(l[5]=n("div",{class:"text"},"数组：",-1)),n("div",null,U(i.value),1)])])]))}},dt=JSON.parse('{"title":"快速排序 Quick Sort","description":"","frontmatter":{},"headers":[],"relativePath":"algorithm/sort/quick_sort.md","filePath":"algorithm/sort/quick_sort.md"}'),it={name:"algorithm/sort/quick_sort.md"},ut=Object.assign(it,{setup(I){return(p,a)=>(V(),w("div",null,[a[0]||(a[0]=J('<h1 id="快速排序-quick-sort" tabindex="-1">快速排序 Quick Sort <a class="header-anchor" href="#快速排序-quick-sort" aria-label="Permalink to &quot;快速排序 Quick Sort&quot;">​</a></h1><h2 id="原理" tabindex="-1">原理 <a class="header-anchor" href="#原理" aria-label="Permalink to &quot;原理&quot;">​</a></h2><p>快速排序（Quick Sort）是一种高效的排序算法，采用了分治法的思想来对数据进行排序。其核心理念是通过选择一个“基准点”（pivot），将数组分成两部分——较小的元素放在基准点的左侧，较大的元素放在右侧，然后对两部分分别递归地进行排序。以下是快速排序的基本步骤：</p><ol><li>选择基准点：通常选择数组中的一个元素作为基准点（可以是第一个、最后一个或中间位置的元素）。</li><li>分区操作：根据基准点，将数组分成两部分。左侧的元素都小于等于基准点，右侧的元素都大于基准点。</li><li>递归排序：分别对左侧和右侧的子数组递归地进行快速排序。</li><li>合并结果：当子数组的大小为1或0时，不需要再排序，最终完成整个排序过程。</li></ol><h2 id="示例" tabindex="-1">示例 <a class="header-anchor" href="#示例" aria-label="Permalink to &quot;示例&quot;">​</a></h2><p>有一组无序数组：</p><table tabindex="0"><thead><tr><th>6</th><th>2</th><th>4</th><th>1</th><th>9</th><th>0</th><th>3</th></tr></thead></table><p>以6作为基准点，第一次遍历将数组分为两部分：</p><p>第一部分：</p><table tabindex="0"><thead><tr><th>2</th><th>4</th><th>1</th><th>0</th><th>3</th></tr></thead></table><p>第二部分：</p><table tabindex="0"><thead><tr><th>9</th></tr></thead></table><p>将第一部分继续快速排序，以2为基准点，遍历将数组分为两部分：</p><p>第一·一部分：</p><table tabindex="0"><thead><tr><th>1</th><th>0</th></tr></thead></table><p>第一·二部分：</p><table tabindex="0"><thead><tr><th>4</th><th>3</th></tr></thead></table><p>将第一·一部分继续快速排序，以1为基准点，遍历将数组分为两部分：</p><p>第一·一·一部分：</p><table tabindex="0"><thead><tr><th>0</th></tr></thead></table><p>第一·一·二部分：</p><p>空</p><p>第一·一部分快速排序的数组长度全部小于等于1，返回数组：</p><table tabindex="0"><thead><tr><th>0</th><th>1</th></tr></thead></table><p>将第一·二部分继续快速排序，以4为基准点，遍历将数组分为两部分：</p><p>第一·二·一部分：</p><table tabindex="0"><thead><tr><th>3</th></tr></thead></table><p>第一·二·二部分：</p><p>空</p><p>第一·二部分快速排序的数组长度全部小于等于1，返回数组：</p><table tabindex="0"><thead><tr><th>3</th><th>4</th></tr></thead></table><p>第一部分快速排序完成，返回数组：</p><table tabindex="0"><thead><tr><th>0</th><th>1</th><th>3</th><th>4</th></tr></thead></table><p>此时第二部分数组长度为1，直接返回数组。</p><p>此时数组为：</p><table tabindex="0"><thead><tr><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>6</th><th>9</th></tr></thead></table><p>排序完成。</p><h2 id="实现" tabindex="-1">实现 <a class="header-anchor" href="#实现" aria-label="Permalink to &quot;实现&quot;">​</a></h2><h3 id="c" tabindex="-1">C++ <a class="header-anchor" href="#c" aria-label="Permalink to &quot;C++&quot;">​</a></h3><h2 id="可视化" tabindex="-1">可视化 <a class="header-anchor" href="#可视化" aria-label="Permalink to &quot;可视化&quot;">​</a></h2>',40)),$(st)]))}});export{dt as __pageData,ut as default};
